# A GitHub Action that uses Gemini 1.5 Pro to automatically review pull requests,
# apply its own suggestions as a patch, commit the changes, and comment on the PR.
# This version adds interactive triggers similar to other code assistant bots.

name: 'Gemini Auto-Review & Implement'

# This action now triggers on PR creation/updates AND on comments in PRs/issues.
on:
  pull_request:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]

# Grant the necessary permissions for the workflow to read code,
# write comments to pull requests, and commit changes to the PR branch.
permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  gemini_review_and_implement:
    name: 'Gemini Review & Implement'
    runs-on: ubuntu-latest
    
    # IMPORTANT: This prevents the action from running on commits made by itself, avoiding infinite loops.
    if: github.actor != 'github-actions[bot]'

    steps:
      # Step 1: Checkout the pull request branch
      # We fetch the full history (fetch-depth: 0) to ensure we can create a proper diff.
      - name: 'Checkout PR Branch'
        uses: actions/checkout@v4
        with:
          # If triggered from a PR, checkout the PR's head ref. Otherwise, checkout the default branch.
          ref: ${{ github.event.pull_request.head.ref || github.ref }}
          fetch-depth: 0

      # Step 2: Configure Git for the Actions bot
      # This sets the author for the commits the action will make.
      - name: 'Set up Git'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      # Step 3: Get the difference (diff) introduced by the pull request
      # This diff is the context we will provide to Gemini for automated reviews.
      # This step only runs for 'pull_request' events.
      - name: 'Get PR Diff'
        id: get_diff
        if: github.event_name == 'pull_request'
        run: |
          git fetch origin ${{ github.event.pull_request.base.ref }}
          PR_DIFF=$(git diff "origin/${{ github.event.pull_request.base.ref }}" "HEAD")
          # The diff is stored in a GitHub Actions output variable for use in later steps.
          echo "diff_content<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_DIFF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        
      # Step 4: Call Gemini 1.5 Pro to analyze the diff or comment, and generate a patch
      # This is the core step of the workflow. It's enhanced to handle both automated and interactive triggers.
      - name: 'Analyze Diff with Gemini and Get Patch'
        id: gemini_analysis
        # FIX: Use the 'env' context to safely pass the diff into the script's environment.
        env:
          PR_DIFF: ${{ steps.get_diff.outputs.diff_content }}
          # Pass the event name and comment body to the script
          EVENT_NAME: ${{ github.event_name }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          # Define the trigger phrase
          TRIGGER_PHRASE: '@gemini-dev'
        run: |
          PROMPT=""
          # Check if the trigger is an interactive comment
          if [[ "$EVENT_NAME" == "issue_comment" && "$COMMENT_BODY" == *"$TRIGGER_PHRASE"* ]]; then
            # Extract the user's prompt from the comment, removing the trigger phrase
            USER_PROMPT=$(echo "$COMMENT_BODY" | sed "s/$TRIGGER_PHRASE//")
            PROMPT_TEMPLATE='''
            You are an expert software engineer acting as an automated code reviewer and implementer.
            A user has summoned you with the following request on a GitHub issue or pull request.
            Your task is to:
            1.  Understand the user's request in the context of the repository.
            2.  Generate a code patch in the universal diff format (`.patch`) that implements the requested changes.
            3.  Provide a concise, bulleted markdown summary of the changes you are making and the reasoning behind them.
            
            Respond with a single, raw JSON object containing two keys: "patch" and "summary".
            - The "patch" key must contain a string of the code changes in the `.patch` format. If no changes are needed, return an empty string.
            - The "summary" key must contain a markdown string for the pull request comment.

            Here is the user's request:
            ---
            '''
            FINAL_PROMPT="${PROMPT_TEMPLATE}${USER_PROMPT}"

          # Check if the trigger is an automated PR review
          elif [[ "$EVENT_NAME" == "pull_request" ]]; then
            PROMPT_TEMPLATE='''
            You are an expert software engineer acting as an automated code reviewer and implementer.
            Your task is to analyze the following code changes provided in a .diff format.
            1.  Review the code for bugs, style inconsistencies, and potential improvements.
            2.  Generate a code patch in the universal diff format (`.patch`) that implements your suggested improvements directly. The patch should be applicable to the original code.
            3.  Provide a concise, bulleted markdown summary of the changes you are making and the reasoning behind them. This summary will be posted as a comment on the pull request.
            
            Respond with a single, raw JSON object containing two keys: "patch" and "summary".
            - The "patch" key must contain a string of the code changes in the `.patch` format. If no changes are needed, return an empty string.
            - The "summary" key must contain a markdown string for the pull request comment.
            
            Here is the diff:
            ```diff
            '''
            FINAL_PROMPT="${PROMPT_TEMPLATE}${PR_DIFF}"$'\n```'
          else
            echo "Not a trigger event. Exiting."
            exit 0
          fi

          JSON_PAYLOAD=$(jq -n --arg prompt "$FINAL_PROMPT" '{
            "contents": [{
              "parts": [{
                "text": $prompt
              }]
            }],
            "generationConfig": {
              "response_mime_type": "application/json",
              "temperature": 0.3
            }
          }')

          GEMINI_RESPONSE=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${{ secrets.GEMINI_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD")

          CLEAN_JSON=$(echo "$GEMINI_RESPONSE" | jq -r '.candidates[0].content.parts[0].text')

          echo "patch<<EOF" >> $GITHUB_OUTPUT
          echo "$CLEAN_JSON" | jq -r .patch >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "summary<<EOF" >> $GITHUB_OUTPUT
          echo "$CLEAN_JSON" | jq -r .summary >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 5: Apply the patch generated by Gemini
      # This step only runs if Gemini provided a non-empty patch.
      - name: 'Apply Patch'
        id: apply_patch
        if: steps.gemini_analysis.outputs.patch != '' && steps.gemini_analysis.outputs.patch != 'null'
        run: |
          echo "Gemini has suggested changes. Applying patch..."
          echo "${{ steps.gemini_analysis.outputs.patch }}" > gemini.patch
          
          if git apply --reject --whitespace=fix gemini.patch; then
            echo "Patch applied successfully."
            echo "applied=true" >> $GITHUB_OUTPUT
          else
            echo "Failed to apply patch automatically. There might be conflicts."
            echo "applied=false" >> $GITHUB_OUTPUT
          fi

      # Step 6: Commit and push the changes if the patch was applied successfully
      - name: 'Commit and Push Changes'
        if: steps.apply_patch.outputs.applied == 'true'
        run: |
          git add .
          # Create a new branch if triggered from an issue comment, otherwise use the existing PR branch
          if [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            BRANCH_NAME="gemini-fix-${{ github.event.issue.number }}"
            git checkout -b $BRANCH_NAME
            git commit -m "feat: Implement changes requested in #${{ github.event.issue.number }}"
            git push origin $BRANCH_NAME
            echo "pushed_branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          else
            git commit -m "feat: Apply Gemini's automated code improvements"
            git push origin ${{ github.head_ref }}
            echo "Committed and pushed Gemini's changes to the PR."
          fi
        id: commit_push

      # Step 7: Comment on the Pull Request with the results
      # This step uses the 'github-script' action to interact with the GitHub API.
      - name: 'Comment on PR or Issue'
        uses: actions/github-script@v7
        with:
          script: |
            const summary = `${{ steps.gemini_analysis.outputs.summary }}`;
            const changes_applied = `${{ steps.apply_patch.outputs.applied }}` === 'true';
            const event_name = `${{ github.event_name }}`;
            const pushed_branch = `${{ steps.commit_push.outputs.pushed_branch }}`;
            let body;

            if (changes_applied) {
              if (event_name === 'issue_comment') {
                const pr_url = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/pull/new/${pushed_branch}`;
                body = ` **Gemini Auto-Implement**\n\nI have implemented the changes you requested. You can review them and open a pull request here: [${pushed_branch}](${pr_url})\n\n**Summary of Changes:**\n\n` + summary;
              } else {
                body = " **Gemini Auto-Review & Implement**\n\nI have analyzed the pull request and implemented the following improvements directly:\n\n" + summary;
              }
            } else if (summary && summary.trim() !== "" && summary.trim() !== 'null') {
              body = " **Gemini Auto-Review**\n\nI have analyzed your request and have the following suggestions. I was unable to apply them automatically:\n\n" + summary;
            } else {
              body = " **Gemini Auto-Review**\n\nI have analyzed the pull request and found no necessary changes. Looks good to me!";
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
