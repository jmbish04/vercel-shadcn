# A GitHub Action that uses Gemini 1.5 Pro to automatically review pull requests,
# apply its own suggestions as a patch, commit the changes, and comment on the PR.

name: 'Gemini Auto-Review & Implement'

# This action triggers on pull request creation, updates (new commits), and when a PR is reopened.
on:
  pull_request:
    types: [opened, synchronize, reopened]

# Grant the necessary permissions for the workflow to read code,
# write comments to pull requests, and commit changes to the PR branch.
permissions:
  contents: write
  pull-requests: write

jobs:
  gemini_review_and_implement:
    name: 'Gemini Review & Implement'
    runs-on: ubuntu-latest
    
    # IMPORTANT: This prevents the action from running on commits made by itself, avoiding infinite loops.
    if: github.actor != 'github-actions[bot]'

    steps:
      # Step 1: Checkout the pull request branch
      # We fetch the full history (fetch-depth: 0) to ensure we can create a proper diff.
      - name: 'Checkout PR Branch'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      # Step 2: Configure Git for the Actions bot
      # This sets the author for the commits the action will make.
      - name: 'Set up Git'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      # Step 3: Get the difference (diff) introduced by the pull request
      # This diff is the context we will provide to Gemini.
      - name: 'Get PR Diff'
        id: get_diff
        run: |
          git fetch origin ${{ github.base_ref }}
          PR_DIFF=$(git diff "origin/${{ github.base_ref }}" "HEAD")
          # The diff is stored in a GitHub Actions output variable for use in later steps.
          echo "diff_content<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_DIFF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      # Step 4: Call Gemini 1.5 Pro to analyze the diff and generate a patch
      # This is the core step of the workflow.
      - name: 'Analyze Diff with Gemini and Get Patch'
        id: gemini_analysis
        run: |
          # The prompt instructs Gemini to act as an expert engineer and return a JSON object
          # containing a code patch and a summary of its changes.
          PROMPT='''
          You are an expert software engineer acting as an automated code reviewer and implementer.
          Your task is to analyze the following code changes provided in a .diff format.
          1.  Review the code for bugs, style inconsistencies, and potential improvements.
          2.  Generate a code patch in the universal diff format (`.patch`) that implements your suggested improvements directly. The patch should be applicable to the original code.
          3.  Provide a concise, bulleted markdown summary of the changes you are making and the reasoning behind them. This summary will be posted as a comment on the pull request.
          
          Respond with a single, raw JSON object containing two keys: "patch" and "summary".
          - The "patch" key must contain a string of the code changes in the `.patch` format. If no changes are needed, return an empty string.
          - The "summary" key must contain a markdown string for the pull request comment.
          
          Here is the diff:
          ```diff
          ${{ steps.get_diff.outputs.diff_content }}
          ```
          '''

          # The payload for the Gemini API call, instructing it to return JSON.
          JSON_PAYLOAD=$(jq -n --arg prompt "$PROMPT" '{
            "contents": [{
              "parts": [{
                "text": $prompt
              }]
            }],
            "generationConfig": {
              "response_mime_type": "application/json",
              "temperature": 0.3
            }
          }')

          # API call to the Gemini 1.5 Pro model.
          # The API key is securely fetched from GitHub secrets.
          GEMINI_RESPONSE=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${{ secrets.GEMINI_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD")

          # Extract the JSON content from the API response.
          CLEAN_JSON=$(echo "$GEMINI_RESPONSE" | jq -r '.candidates[0].content.parts[0].text')

          # Output the patch and summary for use in subsequent steps.
          echo "patch<<EOF" >> $GITHUB_OUTPUT
          echo "$CLEAN_JSON" | jq -r .patch >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "summary<<EOF" >> $GITHUB_OUTPUT
          echo "$CLEAN_JSON" | jq -r .summary >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 5: Apply the patch generated by Gemini
      # This step only runs if Gemini provided a non-empty patch.
      - name: 'Apply Patch'
        id: apply_patch
        if: steps.gemini_analysis.outputs.patch != '' && steps.gemini_analysis.outputs.patch != 'null'
        run: |
          echo "Gemini has suggested changes. Applying patch..."
          echo "${{ steps.gemini_analysis.outputs.patch }}" > gemini.patch
          
          # 'git apply' attempts to apply the patch. It's robust and will fail gracefully if there are conflicts.
          if git apply --reject --whitespace=fix gemini.patch; then
            echo "Patch applied successfully."
            echo "applied=true" >> $GITHUB_OUTPUT
          else
            echo "Failed to apply patch automatically. There might be conflicts."
            echo "applied=false" >> $GITHUB_OUTPUT
          fi

      # Step 6: Commit and push the changes if the patch was applied successfully
      - name: 'Commit and Push Changes'
        if: steps.apply_patch.outputs.applied == 'true'
        run: |
          git add .
          git commit -m "feat: Apply Gemini's automated code improvements"
          git push origin ${{ github.head_ref }}
          echo "Committed and pushed Gemini's changes to the PR."

      # Step 7: Comment on the Pull Request with the results
      # This step uses the 'github-script' action to interact with the GitHub API.
      - name: 'Comment on PR'
        uses: actions/github-script@v7
        with:
          script: |
            const summary = `${{ steps.gemini_analysis.outputs.summary }}`;
            const changes_applied = `${{ steps.apply_patch.outputs.applied }}` === 'true';

            let body;

            if (changes_applied) {
              body = "ðŸ¤– **Gemini Auto-Review & Implement**\n\nI have analyzed the pull request and implemented the following improvements directly:\n\n" + summary;
            } else if (summary && summary.trim() !== "" && summary.trim() !== 'null') {
              body = "ðŸ¤– **Gemini Auto-Review**\n\nI have analyzed the pull request and have the following suggestions. I was unable to apply them automatically:\n\n" + summary;
            } else {
              body = "ðŸ¤– **Gemini Auto-Review**\n\nI have analyzed the pull request and found no necessary changes. Looks good to me!";
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

